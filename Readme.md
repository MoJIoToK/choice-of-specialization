# Итоговая проверочная работа

Итогавая работа состояла из 4 пунктов:

1. [*Создать репозитарий на GitHub;*](#Repo)
2. [*Изобразить блок-схему алгоритма;*](#Block)
3. [*Снабдить репозитарий оформленным текстовым описанием решения (файл README.md);*](#3)
4. [*Написать программу, решающую задачу.*](#Код)

## Задача

Написать программу, которая из имеющегося массива строк формирует массив из строк, длина которых меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

Решение
===

## 1. <a name="Repo"></a> Создание репозитария
Как создается удаленный репозитарий на GitHub мы изучали в [курсе **"Контроль версий"**](https://github.com/MoJIoToK/Control_Version/blob/main/Git%20and%20Markdown%20Instruction.md "Это моя инструкция").

Вкратце, на сайте GitHub нажимаем зеленую кнопочку __"New"__, даём название нашему репозитарию, описание, настраиваем приватность и прочие настройки и нажимаем зеленую кнопку внизу __"Create repository"__

## 2. <a name="Block"></a> Блок-схема 

Составлять блок-схемы мы учились на курсе "**Введение в программирование**".

Позволю себе немного объяснить мое решение. Реализацию программы я написал тремя похожими способами и решил оставить все три. Но поскольку они в определенной степени похожи, то блок-схему я изобразил одну, для второго варианта. 
- Сначала необходимо ввести данные. Вводные данные - массив строк. Ввод может быть осуществлен как изначально в программе, либо с клавиатуры.

- Затем идет инициализация переменных. Это создание выходного массива, инициализация переменных `i`, `k` и `strMas1.Length`. Последнюю переменную необязательно инициализировать, т.к. мы можем в программе писать непосредственно `strMas1.Length`, что собственно сделал я.

- После идет цикл `for` со счётчиком `i`. Данный цикл нужен для перебора всех строк в массиве.

- В цикл `for` вложено условие `if`. В данном условие проверяется что строка меньше 3 элементов. У данного условия имеется свой счетчик `k`. Зачем он нужен? Он необходим для того чтобы в выходном массиве результирующие строки были последовательо расположены. Может получится так, что в исходном массиве строки, удовлетворяющие условию, стоят непоследовательно и если не было бы счетчика `k`, то они бы приняли те же индексы в выходном массиве. Будем считать что такого нам не нужно.

- Соответственно если условие соблюдается, то необходимо записать строку в выходной массив. 

- Затем выполняем инкрементирование.

- Вне условия `if` также делаем инкрементирование.

- Возвращаемся к проверке условия что `i` меньше длины исходного массива.

- Если программа проверила все элементы массива, выводим результат.
## 3. Readme.md
Файл __Readme.md__ оформляю в данный момент. Работу с файлами с расширением `.md` изучали также на [курсе **"Контроль версий"**](https://github.com/MoJIoToK/Control_Version/blob/main/Git%20and%20Markdown%20Instruction.md "Это моя инструкция").

Имеется много разных способов украсить текстовый файл. Некоторые из способов я пытаюсь внедрить в данную инструкцию.

## 4. Код

Как я уже отмечал [выше](#2), я написал три похожих варианта программы. 

Прокомментирую немного каждый.
### Первый

Самый простой, решил не усложнять и задать исходный массив изначально. Конечно можно было задавать массив через клавиатуру, но пока что я решил не делать этого.

Далее идет цикл `for`, описанный в блок-схеме и сразу печать строк, если выполняется условие.

#### *Недостатки* 

- Массив по сути задан жестко;
- Не создается выходного массива, куда будут записываться элементы исходного, удовлетворяющие условию.
### Второй

Массив также задан жестко. Создан второй массив, такой же размерности что и первый. В цикл вложено условие, при выполнении которого в результирующий массив записываются необходимые строки.

Выводится исходный массив. 
Поскольку результирующий массив такой же размерности что и исходный, но он может быть заполнен неполностью, то нулевые элементы как бы удаляются. Затем выводится результирующий массив.
#### *Недостатки* 

- Массив по сути задан жестко;
- Сложно реализован вывод результата. Можно было бы выводить через цикл `for`, но код был бы больше. Вывод массива можно было поместить в отдельный метод. Это я и сделал в следующем варианте.

### Третий

Третий вариант аналогичен второму, за исключением того основные действия происходят в методах и наличие дополнительной проверки, которая позволит определить какой размерности необходимо создать результирующий массив.

Думаю, что комментарии излишни.
